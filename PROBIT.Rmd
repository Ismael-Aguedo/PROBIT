---
title: "Modelo Probit Microeconometria"
author: "Ismael Giancarlo Aguedo Aguilar"
output:
  rmdformats::material
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#Cargando las librerías
  library(readxl)
  library(aod)
  library(ggplot2)
  library(performance)
  library(pROC)
  library(dplyr)
  library(lmtest)
  library(mfx)
  library(knitr)
  library(kableExtra)
```

# <span style="color: #008080;">Datos</span>


Incluimos los datos de 32 observaciones sobre el efecto de un sistema personalizado de
instrucción (PSI) en las calificaciones del curso:

- Variable Endogena
GRADE:(GRADE = 1 si la calificación es obtenida es A, GRADE = 0 si la calificación es obtenida es diferente de A)

- Variables Exógenas:
GPA: Promedio de notas de entrada; TUCE: Puntuación en un examen de principio del curso; PSI:(PSI = 1 si se utiliza el nuevo método, PSI = 0 si no se utiliza el nuevo método)

```{r, include=FALSE}
# Cargar los datos
  ruta_excel <- "C:\\github\\Estimacion_Probit_Microeconometria\\instruccion.xlsx"
  instruc <- read_excel(ruta_excel, sheet = 'Hoja1')
  instruc$GRADE <- as.factor(instruc$GRADE)
  instruc$PSI <- as.factor(instruc$PSI)
# Crear y estilizar la tabla
  tabla<-kable(instruc, caption = "Efecto de un sistema personalizado de
instrucción", align = "c") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), font_size = 12, full_width = FALSE) %>%
  column_spec(column = 1:ncol(instruc), width = "9em") 
```

```{r, echo=FALSE, results='asis'}
  tabla
```

# <span style="color: #008080;">Estimación del Modelo</span> 

## <span style="color: #8FBC8B;">Estimación de los coeficientes Probit:</span> 

Bien por motivos didácticos mostramos solamente los coeficientes, con el cual podemos plasmar la ecuación estimada y la probabilidad de que GRADE sea igual a 1:

```{r, echo=FALSE, results='hide'}
# Ajustar el modelo probit
  fit <- glm(GRADE ~ GPA + TUCE + PSI, data = instruc, family = binomial(link = "probit"))
```

```{r, echo=FALSE, include=FALSE}
# Resumen del modelo
  summary(fit)
```

```{r, echo=FALSE, include=FALSE}
# Mostrar resultados con 6 decimales
summary_fit <- summary(fit)
coefficients_6dec <- round(summary_fit$coefficients, 6)
stderr_6dec <- round(summary_fit$coefficients[, "Std. Error"], 6)
z_values_6dec <- round(summary_fit$coefficients[, "z value"], 6)
p_values_6dec <- round(summary_fit$coefficients[, "Pr(>|z|)"], 6)
```

```{r, comment='', results='hold', echo=FALSE}
cat("\nCoefficients:\n")
print(coefficients_6dec)

#cat("\nStandard errors:\n")
#print(stderr_6dec)

#cat("\nZ values:\n")
#print(z_values_6dec)

#cat("\nP values:\n")
#print(p_values_6dec)
```

# <span style="color: #008080;">Ecuación Probit</span>

$$\scriptsize{I_{GRADE}=\beta_{1}+\beta_{2}\cdot GPA+\beta_{3}\cdot TUCE+\beta_{4}\cdot PSI}$$
donde $I_{GRADE}$ representa el indicador binomial de GRADE.

## <span style="color: #8FBC8B;">Ecuación del pronostico:</span>

$$\scriptsize{P(GRADE=1)=1-\Phi-(\beta_{1}+\beta_{2}\cdot GPA+\beta_{3}\cdot TUCE+\beta_{4}\cdot PSI)}$$
remplazando con los coeficientes obtenidos tenemos que:

$$\scriptsize{P(GRADE=1) = 1 - \Phi\left(-(-7.452313 + 1.625812 \cdot GPA + 0.051728 \cdot TUCE + 1.426331 \cdot PSI)\right)}$$
Evidentemente para lograr obtener la probabilidad acumulada de que (GRADE=1), necesitamos los valores de las variables que en este caso no los tenemos. Si tuviéramos los valores y sabiendo que una muestra de datos lo suficientemente grande tiende a una distribución normal en Probit, podríamos determinar mediante la tabla de distribución normal acumulada dicha probabilidad.

A continuación muestro un grafico de ejemplo de lo que seria la probabilidad acumulada, el area sombreada:



```{r, fig.cap="Distribución Normal Acumulativa", echo=FALSE, message=FALSE, warning=FALSE}
# Definir los parámetros de la distribución normal
mu <- 1000
sigma <- 50
# Límite inferior y superior
lb <- mu - 3 * sigma  # Límite inferior (3 desviaciones estándar por debajo de la media)
ub <- 1010  # Límite superior
# Crear una rejilla de valores x
x <- seq(lb, mu + 3 * sigma, length = 100)
y <- dnorm(x, mu, sigma)  # Densidad
# Crear el gráfico usando plot
plot(x, y, type = "l", lwd = 2, col = "blue", ylab = "Densidad", xlab = "Peso")
abline(v = ub) 
# Sombra del área hasta la línea vertical
polygon(c(lb, x[x <= ub], ub), c(0, y[x <= ub], 0), col = rgb(0, 0, 1, alpha = 0.5))
```


# <span style="color: #008080;">R^2 McFadden</span>

El R^2 McFadden es un pseudo R^2

```{r,  include=FALSE}
r2_mc <- r2_mcfadden(fit)
```
```{r, results='hold', echo=FALSE, comment=''}
print(paste("R2 de McFadden:", r2_mc))
```

### R^2 de Conteo

```{r, include=FALSE}
# Predicciones y residuos
predicciones <- predict(fit, type = "response")
residuos <- residuals(fit, type = "response")

# Porcentaje de errores
pred_corr <- sum(residuos >= -0.5 & residuos <= 0.5)
total_observaciones <- nobs(fit)
porc_error <- ((total_observaciones - pred_corr) / total_observaciones) * 100
cat("Porcentaje de errores en los residuos:", porc_error, "%\n")

# R^2 de Conteo
r2_conteo <- pred_corr / total_observaciones
```

```{r, comment='', echo=FALSE, results='hold'}
cat("R2 de conteo:", r2_conteo, "\n")
```

```{r, include=FALSE}
roc_curve <- roc(instruc$GRADE, predicciones)
auc_value <- auc(roc_curve)
```

```{r, include=FALSE}
# Crear el gráfico de la curva ROC usando ggroc()
roc_plot <- ggroc(roc_curve) +
  labs(title = "Curva ROC",
       x = "1 - Especificidad",
       y = "Sensibilidad") +
  theme_gray() +
  theme(
    panel.grid.major = element_line(color = "gray", linetype = "dashed"),
    panel.grid.minor = element_blank()
  )
```

```{r, comment='', echo=FALSE, results='hold'}
print(roc_plot)
```

```{r, comment='', echo=FALSE, results='hold'}
cat("Área bajo la curva ROC (AUC):", auc_value, "\n")
```

### Estadístico de la razón de verosimilitud (RV)

```{r,include=FALSE}
lr_test <- lrtest(fit)
```
```{r, comment='', echo=FALSE, results='hold'}
print(lr_test)
```

```{r, include=FALSE}
# Ordenar las predicciones de menor a mayor
predicciones_ordenadas <- sort(predicciones)
```

### Grafico de las predicciones ordenadas

```{r, include=FALSE}
# Curva de PROBIT
plot_predprobit <- ggplot() +
  geom_line(aes(x = seq_along(predicciones_ordenadas), y = predicciones_ordenadas), color = "red") +
  labs(title = "Curva S de Probit",
       x = "Observaciones",
       y = "Probabilidad acumulativa") +
  theme_minimal() +
  theme(panel.grid.major = element_line(color = "azure4", linetype = "dashed"),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = "ivory2")) +
  scale_x_continuous(expand = c(0, 0))
```

```{r, comment='', echo=FALSE, results='hold'}
print(plot_predprobit)
```

## Efectos Marginales en PROBIT

```{r, include=FALSE}
# Calcula los efectos marginales
efectos_marginales <- probitmfx(fit, data = instruc)
```

```{r, comment='', echo=FALSE, results='hold'}
print(efectos_marginales)
```





